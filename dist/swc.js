/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SWC"] = factory();
	else
		root["SWC"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/context-manager.js":
/*!***********************************!*\
  !*** ./src/js/context-manager.js ***!
  \***********************************/
/***/ ((module) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\r\n * Context Manager\r\n * Manages conversation context for AI interactions\r\n * Implements sliding window for context management\r\n */\nvar ContextManager = /*#__PURE__*/function () {\n  function ContextManager() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ContextManager);\n    this.maxMessages = config.maxMessages || 10;\n    this.systemPrompt = config.systemPrompt || \"You are a helpful assistant.\";\n    this.contextWindow = [];\n    this.totalTokensEstimate = 0;\n    this.maxTokens = config.maxTokens || 2000; // Context token limit\n    this.debug = config.debug || false;\n  }\n\n  /**\r\n   * Add message to context\r\n   * @param {string} role - Message role: 'system', 'user', or 'assistant'\r\n   * @param {string} content - Message content\r\n   */\n  return _createClass(ContextManager, [{\n    key: \"addMessage\",\n    value: function addMessage(role, content) {\n      if (!role || !content) {\n        console.warn(\"[ContextManager] Invalid message: role and content are required\");\n        return;\n      }\n      var message = {\n        role: role,\n        content: content,\n        timestamp: new Date().toISOString(),\n        tokens: this._estimateTokens(content)\n      };\n      this.contextWindow.push(message);\n      this.totalTokensEstimate += message.tokens;\n      if (this.debug) {\n        console.log(\"[ContextManager] Added \".concat(role, \" message (\").concat(message.tokens, \" tokens)\"));\n        console.log(\"[ContextManager] Total messages: \".concat(this.contextWindow.length, \", estimated tokens: \").concat(this.totalTokensEstimate));\n      }\n\n      // Trim context if needed\n      this._trimContext();\n    }\n\n    /**\r\n     * Get formatted context for API\r\n     * @param {boolean} includeSystem - Include system prompt\r\n     * @returns {Array} Array of message objects for API\r\n     */\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      var includeSystem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var messages = [];\n\n      // Add system prompt if requested\n      if (includeSystem && this.systemPrompt) {\n        messages.push({\n          role: \"system\",\n          content: this.systemPrompt\n        });\n      }\n\n      // Add context window messages (without metadata)\n      this.contextWindow.forEach(function (msg) {\n        messages.push({\n          role: msg.role,\n          content: msg.content\n        });\n      });\n      if (this.debug) {\n        console.log(\"[ContextManager] Returning \".concat(messages.length, \" messages for API\"));\n      }\n      return messages;\n    }\n\n    /**\r\n     * Get last N messages from context\r\n     * @param {number} count - Number of messages to retrieve\r\n     * @returns {Array} Last N messages\r\n     */\n  }, {\n    key: \"getLastMessages\",\n    value: function getLastMessages() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      return this.contextWindow.slice(-count);\n    }\n\n    /**\r\n     * Clear all context except system prompt\r\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.contextWindow = [];\n      this.totalTokensEstimate = 0;\n      if (this.debug) {\n        console.log(\"[ContextManager] Context cleared\");\n      }\n    }\n\n    /**\r\n     * Update system prompt\r\n     * @param {string} prompt - New system prompt\r\n     */\n  }, {\n    key: \"setSystemPrompt\",\n    value: function setSystemPrompt(prompt) {\n      this.systemPrompt = prompt;\n      if (this.debug) {\n        console.log(\"[ContextManager] System prompt updated\");\n      }\n    }\n\n    /**\r\n     * Get context statistics\r\n     * @returns {Object} Context statistics\r\n     */\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return {\n        messageCount: this.contextWindow.length,\n        estimatedTokens: this.totalTokensEstimate,\n        maxMessages: this.maxMessages,\n        maxTokens: this.maxTokens,\n        systemPrompt: this.systemPrompt ? this.systemPrompt.substring(0, 50) + \"...\" : null\n      };\n    }\n\n    /**\r\n     * Trim context to stay within limits\r\n     * Uses sliding window approach - removes oldest messages first\r\n     * Always keeps at least one exchange (user + assistant)\r\n     * @private\r\n     */\n  }, {\n    key: \"_trimContext\",\n    value: function _trimContext() {\n      // Trim by message count\n      while (this.contextWindow.length > this.maxMessages) {\n        var removed = this.contextWindow.shift();\n        this.totalTokensEstimate = Math.max(0, this.totalTokensEstimate - removed.tokens);\n        if (this.debug) {\n          console.log(\"[ContextManager] Removed oldest message (\".concat(removed.role, \"), \").concat(this.contextWindow.length, \" remaining\"));\n        }\n      }\n\n      // Trim by token count (more aggressive if needed)\n      while (this.totalTokensEstimate > this.maxTokens && this.contextWindow.length > 2) {\n        var _removed = this.contextWindow.shift();\n        this.totalTokensEstimate = Math.max(0, this.totalTokensEstimate - _removed.tokens);\n        if (this.debug) {\n          console.log(\"[ContextManager] Removed message to reduce tokens (\".concat(_removed.role, \"), \").concat(this.totalTokensEstimate, \" tokens remaining\"));\n        }\n      }\n    }\n\n    /**\r\n     * Estimate token count for a message\r\n     * Simple approximation: ~4 characters per token\r\n     * @private\r\n     */\n  }, {\n    key: \"_estimateTokens\",\n    value: function _estimateTokens(text) {\n      if (!text) return 0;\n\n      // Rough estimation: 1 token â‰ˆ 4 characters for English text\n      // This is a simplified approach; real tokenization is more complex\n      return Math.ceil(text.length / 4);\n    }\n\n    /**\r\n     * Summarize context for long conversations\r\n     * Creates a summary of older messages to reduce token count\r\n     * @returns {string} Summary of context\r\n     */\n  }, {\n    key: \"summarize\",\n    value: function summarize() {\n      if (this.contextWindow.length < 3) {\n        return \"\";\n      }\n\n      // Get first half of messages\n      var messagesToSummarize = this.contextWindow.slice(0, Math.floor(this.contextWindow.length / 2));\n\n      // Create summary\n      var summary = messagesToSummarize.map(function (msg) {\n        var preview = msg.content.substring(0, 100);\n        return \"\".concat(msg.role, \": \").concat(preview).concat(msg.content.length > 100 ? \"...\" : \"\");\n      }).join(\"\\n\");\n      return \"Previous conversation summary:\\n\".concat(summary);\n    }\n\n    /**\r\n     * Export context for persistence\r\n     * @returns {Object} Serializable context data\r\n     */\n  }, {\n    key: \"export\",\n    value: function _export() {\n      return {\n        version: \"1.0\",\n        timestamp: new Date().toISOString(),\n        systemPrompt: this.systemPrompt,\n        maxMessages: this.maxMessages,\n        maxTokens: this.maxTokens,\n        contextWindow: this.contextWindow.map(function (msg) {\n          return {\n            role: msg.role,\n            content: msg.content,\n            timestamp: msg.timestamp\n          };\n        }),\n        stats: this.getStats()\n      };\n    }\n\n    /**\r\n     * Import context from exported data\r\n     * @param {Object} data - Exported context data\r\n     * @returns {boolean} Success status\r\n     */\n  }, {\n    key: \"import\",\n    value: function _import(data) {\n      var _this = this;\n      try {\n        if (!data || !data.contextWindow || !Array.isArray(data.contextWindow)) {\n          throw new Error(\"Invalid context data format\");\n        }\n\n        // Clear existing context\n        this.clear();\n\n        // Import settings\n        if (data.systemPrompt) {\n          this.systemPrompt = data.systemPrompt;\n        }\n        if (data.maxMessages) {\n          this.maxMessages = data.maxMessages;\n        }\n        if (data.maxTokens) {\n          this.maxTokens = data.maxTokens;\n        }\n\n        // Import messages\n        data.contextWindow.forEach(function (msg) {\n          _this.addMessage(msg.role, msg.content);\n        });\n        if (this.debug) {\n          console.log(\"[ContextManager] Imported \".concat(this.contextWindow.length, \" messages\"));\n        }\n        return true;\n      } catch (error) {\n        console.error(\"[ContextManager] Import failed:\", error);\n        return false;\n      }\n    }\n\n    /**\r\n     * Inject knowledge base context into system prompt\r\n     * @param {string} knowledge - Knowledge base information\r\n     */\n  }, {\n    key: \"injectKnowledge\",\n    value: function injectKnowledge(knowledge) {\n      if (!knowledge) return;\n      var enhancedPrompt = \"\".concat(this.systemPrompt, \"\\n\\nRelevant knowledge base information:\\n\").concat(knowledge);\n      this.setSystemPrompt(enhancedPrompt);\n      if (this.debug) {\n        console.log(\"[ContextManager] Knowledge injected into system prompt\");\n      }\n    }\n  }]);\n}(); // Export for use in other modules\nif ( true && module.exports) {\n  module.exports = ContextManager;\n}\n\n//# sourceURL=webpack://SWC/./src/js/context-manager.js?");

/***/ }),

/***/ "./src/js/openrouter-client.js":
/*!*************************************!*\
  !*** ./src/js/openrouter-client.js ***!
  \*************************************/
/***/ ((module) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\r\n * OpenRouter API Client\r\n * Handles communication with OpenRouter (OpenAI-compatible) API\r\n * Supports streaming responses and error handling\r\n */\nvar OpenRouterAPI = /*#__PURE__*/function () {\n  function OpenRouterAPI(config) {\n    _classCallCheck(this, OpenRouterAPI);\n    this.apiKey = config.apiKey;\n    this.baseURL = config.baseURL || \"https://openrouter.ai/api/v1\";\n    this.model = config.model || \"openai/gpt-3.5-turbo\";\n    this.maxTokens = config.maxTokens || 500;\n    this.temperature = config.temperature || 0.7;\n    this.siteName = config.siteName || \"SenangWebs Chatbot\";\n    this.siteUrl = config.siteUrl || (typeof window !== \"undefined\" ? window.location.origin : \"\");\n    this.timeout = config.timeout || 30000; // 30 seconds\n    this.retryAttempts = config.retryAttempts || 2;\n    this.retryDelay = config.retryDelay || 1000; // 1 second\n    this.debug = config.debug || false;\n    this.abortController = null;\n    this.validateConfig();\n  }\n\n  /**\r\n   * Validate configuration\r\n   * @throws {Error} if configuration is invalid\r\n   */\n  return _createClass(OpenRouterAPI, [{\n    key: \"validateConfig\",\n    value: function validateConfig() {\n      if (!this.apiKey || this.apiKey.trim() === \"\") {\n        throw new Error(\"OpenRouter API key is required\");\n      }\n      if (!this.baseURL || !this.baseURL.startsWith(\"http\")) {\n        throw new Error(\"Invalid base URL\");\n      }\n      if (this.maxTokens < 1 || this.maxTokens > 32768) {\n        console.warn(\"maxTokens should be between 1 and 32768, using default 500\");\n        this.maxTokens = 500;\n      }\n      if (this.temperature < 0 || this.temperature > 2) {\n        console.warn(\"temperature should be between 0 and 2, using default 0.7\");\n        this.temperature = 0.7;\n      }\n    }\n\n    /**\r\n     * Send message to OpenRouter API with streaming support\r\n     * @param {Array} messages - Array of message objects {role, content}\r\n     * @param {Function} onChunk - Callback for each chunk of streamed data\r\n     * @param {Function} onComplete - Callback when streaming is complete\r\n     * @param {Function} onError - Callback for errors\r\n     * @returns {Promise<Object>} Complete response object\r\n     */\n  }, {\n    key: \"sendMessage\",\n    value: (function () {\n      var _sendMessage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(messages, onChunk, onComplete, onError) {\n        var attempt, lastError, response, errorData, result, delay;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              attempt = 0;\n              lastError = null;\n            case 2:\n              if (!(attempt <= this.retryAttempts)) {\n                _context.next = 35;\n                break;\n              }\n              _context.prev = 3;\n              if (this.debug) {\n                console.log(\"[OpenRouterAPI] Attempt \".concat(attempt + 1, \"/\").concat(this.retryAttempts + 1));\n                console.log(\"[OpenRouterAPI] Sending messages:\", messages);\n              }\n              _context.next = 7;\n              return this._makeRequest(messages);\n            case 7:\n              response = _context.sent;\n              if (response.ok) {\n                _context.next = 13;\n                break;\n              }\n              _context.next = 11;\n              return response.json()[\"catch\"](function () {\n                return {};\n              });\n            case 11:\n              errorData = _context.sent;\n              throw this._handleAPIError(response.status, errorData);\n            case 13:\n              _context.next = 15;\n              return this._handleStreamingResponse(response, onChunk);\n            case 15:\n              result = _context.sent;\n              if (onComplete) {\n                onComplete(result);\n              }\n              return _context.abrupt(\"return\", result);\n            case 20:\n              _context.prev = 20;\n              _context.t0 = _context[\"catch\"](3);\n              lastError = _context.t0;\n              if (this.debug) {\n                console.error(\"[OpenRouterAPI] Attempt \".concat(attempt + 1, \" failed:\"), _context.t0);\n              }\n\n              // Don't retry on certain errors\n              if (!this._shouldNotRetry(_context.t0)) {\n                _context.next = 27;\n                break;\n              }\n              if (onError) {\n                onError(_context.t0);\n              }\n              throw _context.t0;\n            case 27:\n              attempt++;\n\n              // Wait before retry (exponential backoff)\n              if (!(attempt <= this.retryAttempts)) {\n                _context.next = 33;\n                break;\n              }\n              delay = this.retryDelay * Math.pow(2, attempt - 1);\n              if (this.debug) {\n                console.log(\"[OpenRouterAPI] Retrying in \".concat(delay, \"ms...\"));\n              }\n              _context.next = 33;\n              return this._sleep(delay);\n            case 33:\n              _context.next = 2;\n              break;\n            case 35:\n              // All retries failed\n              if (onError) {\n                onError(lastError);\n              }\n              throw lastError;\n            case 37:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 20]]);\n      }));\n      function sendMessage(_x, _x2, _x3, _x4) {\n        return _sendMessage.apply(this, arguments);\n      }\n      return sendMessage;\n    }()\n    /**\r\n     * Make HTTP request to OpenRouter API\r\n     * @private\r\n     */\n    )\n  }, {\n    key: \"_makeRequest\",\n    value: (function () {\n      var _makeRequest2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(messages) {\n        var _this = this;\n        var timeoutId, response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.abortController = new AbortController();\n              timeoutId = setTimeout(function () {\n                return _this.abortController.abort();\n              }, this.timeout);\n              _context2.prev = 2;\n              _context2.next = 5;\n              return fetch(\"\".concat(this.baseURL, \"/chat/completions\"), {\n                method: \"POST\",\n                headers: {\n                  Authorization: \"Bearer \".concat(this.apiKey),\n                  \"Content-Type\": \"application/json\",\n                  \"HTTP-Referer\": this.siteUrl,\n                  \"X-Title\": this.siteName\n                },\n                body: JSON.stringify({\n                  model: this.model,\n                  messages: messages,\n                  max_tokens: this.maxTokens,\n                  temperature: this.temperature,\n                  stream: true\n                }),\n                signal: this.abortController.signal\n              });\n            case 5:\n              response = _context2.sent;\n              clearTimeout(timeoutId);\n              return _context2.abrupt(\"return\", response);\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](2);\n              clearTimeout(timeoutId);\n              throw _context2.t0;\n            case 14:\n              _context2.prev = 14;\n              // Clean up timeout in all cases\n              clearTimeout(timeoutId);\n              return _context2.finish(14);\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[2, 10, 14, 17]]);\n      }));\n      function _makeRequest(_x5) {\n        return _makeRequest2.apply(this, arguments);\n      }\n      return _makeRequest;\n    }()\n    /**\r\n     * Handle streaming response from API\r\n     * @private\r\n     */\n    )\n  }, {\n    key: \"_handleStreamingResponse\",\n    value: (function () {\n      var _handleStreamingResponse2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(response, onChunk) {\n        var reader, decoder, buffer, fullContent, _yield$reader$read, done, value, lines, _iterator, _step, line, trimmedLine, _data$choices, _data$choices2, data, content;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              reader = response.body.getReader();\n              decoder = new TextDecoder();\n              buffer = \"\";\n              fullContent = \"\";\n              _context3.prev = 4;\n            case 5:\n              if (false) {}\n              _context3.next = 8;\n              return reader.read();\n            case 8:\n              _yield$reader$read = _context3.sent;\n              done = _yield$reader$read.done;\n              value = _yield$reader$read.value;\n              if (!done) {\n                _context3.next = 13;\n                break;\n              }\n              return _context3.abrupt(\"break\", 41);\n            case 13:\n              buffer += decoder.decode(value, {\n                stream: true\n              });\n              lines = buffer.split(\"\\n\");\n              buffer = lines.pop() || \"\"; // Keep incomplete line in buffer\n              _iterator = _createForOfIteratorHelper(lines);\n              _context3.prev = 17;\n              _iterator.s();\n            case 19:\n              if ((_step = _iterator.n()).done) {\n                _context3.next = 31;\n                break;\n              }\n              line = _step.value;\n              trimmedLine = line.trim();\n              if (!(trimmedLine === \"\")) {\n                _context3.next = 24;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 29);\n            case 24:\n              if (!(trimmedLine === \"data: [DONE]\")) {\n                _context3.next = 26;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 29);\n            case 26:\n              if (trimmedLine.startsWith(\"data: \")) {\n                _context3.next = 28;\n                break;\n              }\n              return _context3.abrupt(\"continue\", 29);\n            case 28:\n              try {\n                data = JSON.parse(trimmedLine.substring(6));\n                content = (_data$choices = data.choices) === null || _data$choices === void 0 || (_data$choices = _data$choices[0]) === null || _data$choices === void 0 || (_data$choices = _data$choices.delta) === null || _data$choices === void 0 ? void 0 : _data$choices.content;\n                if (content) {\n                  fullContent += content;\n                  if (onChunk) {\n                    onChunk({\n                      content: content,\n                      fullContent: fullContent,\n                      done: false\n                    });\n                  }\n                }\n\n                // Check if streaming is finished\n                if ((_data$choices2 = data.choices) !== null && _data$choices2 !== void 0 && (_data$choices2 = _data$choices2[0]) !== null && _data$choices2 !== void 0 && _data$choices2.finish_reason) {\n                  if (this.debug) {\n                    console.log(\"[OpenRouterAPI] Stream finished:\", data.choices[0].finish_reason);\n                  }\n                }\n              } catch (parseError) {\n                if (this.debug) {\n                  console.warn(\"[OpenRouterAPI] Failed to parse SSE data:\", trimmedLine, parseError);\n                }\n              }\n            case 29:\n              _context3.next = 19;\n              break;\n            case 31:\n              _context3.next = 36;\n              break;\n            case 33:\n              _context3.prev = 33;\n              _context3.t0 = _context3[\"catch\"](17);\n              _iterator.e(_context3.t0);\n            case 36:\n              _context3.prev = 36;\n              _iterator.f();\n              return _context3.finish(36);\n            case 39:\n              _context3.next = 5;\n              break;\n            case 41:\n              return _context3.abrupt(\"return\", {\n                content: fullContent,\n                model: this.model,\n                done: true\n              });\n            case 44:\n              _context3.prev = 44;\n              _context3.t1 = _context3[\"catch\"](4);\n              if (!(_context3.t1.name === \"AbortError\")) {\n                _context3.next = 48;\n                break;\n              }\n              throw new Error(\"Request cancelled by user\");\n            case 48:\n              throw _context3.t1;\n            case 49:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[4, 44], [17, 33, 36, 39]]);\n      }));\n      function _handleStreamingResponse(_x6, _x7) {\n        return _handleStreamingResponse2.apply(this, arguments);\n      }\n      return _handleStreamingResponse;\n    }()\n    /**\r\n     * Handle API errors and create meaningful error messages\r\n     * @private\r\n     */\n    )\n  }, {\n    key: \"_handleAPIError\",\n    value: function _handleAPIError(status, errorData) {\n      var _errorData$error;\n      var errorMessage = ((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || \"Unknown error occurred\";\n      switch (status) {\n        case 401:\n          return new Error(\"Invalid API key. Please check your OpenRouter API key.\");\n        case 403:\n          return new Error(\"Access forbidden. Please check your API key permissions.\");\n        case 429:\n          var error = new Error(\"Rate limit exceeded. Please try again later.\");\n          error.isRateLimit = true;\n          return error;\n        case 500:\n        case 502:\n        case 503:\n          return new Error(\"OpenRouter service is temporarily unavailable. Please try again.\");\n        case 400:\n          return new Error(\"Bad request: \".concat(errorMessage));\n        default:\n          return new Error(\"API error (\".concat(status, \"): \").concat(errorMessage));\n      }\n    }\n\n    /**\r\n     * Check if error should not be retried\r\n     * @private\r\n     */\n  }, {\n    key: \"_shouldNotRetry\",\n    value: function _shouldNotRetry(error) {\n      // Don't retry on auth errors, bad requests, or user cancellation\n      if (error.message.includes(\"Invalid API key\")) return true;\n      if (error.message.includes(\"Access forbidden\")) return true;\n      if (error.message.includes(\"Bad request\")) return true;\n      if (error.message.includes(\"cancelled by user\")) return true;\n      return false;\n    }\n\n    /**\r\n     * Cancel ongoing request\r\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.abortController) {\n        this.abortController.abort();\n        if (this.debug) {\n          console.log(\"[OpenRouterAPI] Request cancelled\");\n        }\n      }\n    }\n\n    /**\r\n     * Get model information\r\n     */\n  }, {\n    key: \"getModelInfo\",\n    value: function getModelInfo() {\n      return {\n        model: this.model,\n        maxTokens: this.maxTokens,\n        temperature: this.temperature\n      };\n    }\n\n    /**\r\n     * Sleep utility for retry delays\r\n     * @private\r\n     */\n  }, {\n    key: \"_sleep\",\n    value: function _sleep(ms) {\n      return new Promise(function (resolve) {\n        return setTimeout(resolve, ms);\n      });\n    }\n  }]);\n}(); // Export for use in other modules\nif ( true && module.exports) {\n  module.exports = OpenRouterAPI;\n}\n\n//# sourceURL=webpack://SWC/./src/js/openrouter-client.js?");

/***/ }),

/***/ "./src/js/swc.js":
/*!***********************!*\
  !*** ./src/js/swc.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SenangWebsChatbot: () => (/* binding */ SenangWebsChatbot),\n/* harmony export */   defaultKnowledgeBase: () => (/* binding */ defaultKnowledgeBase),\n/* harmony export */   initializeChatbot: () => (/* binding */ initializeChatbot)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// SenangWebs Chatbot Library\n\n// Import API classes if they exist (for modular usage)\n// These classes can also be included separately in HTML\nvar OpenRouterAPI, ContextManager;\n\n// Try to import classes (for webpack bundling)\ntry {\n  if (true) {\n    OpenRouterAPI = __webpack_require__(/*! ./openrouter-client.js */ \"./src/js/openrouter-client.js\");\n    ContextManager = __webpack_require__(/*! ./context-manager.js */ \"./src/js/context-manager.js\");\n  }\n} catch (e) {\n  // Classes will be loaded from global scope or separate script tags\n}\n\n// Make classes available globally if not already defined\nif (typeof window !== \"undefined\") {\n  if (!window.OpenRouterAPI && typeof OpenRouterAPI !== \"undefined\") {\n    window.OpenRouterAPI = OpenRouterAPI;\n  }\n  if (!window.ContextManager && typeof ContextManager !== \"undefined\") {\n    window.ContextManager = ContextManager;\n  }\n\n  // Use global classes if available\n  OpenRouterAPI = window.OpenRouterAPI || OpenRouterAPI;\n  ContextManager = window.ContextManager || ContextManager;\n}\nvar SenangWebsChatbot = /*#__PURE__*/function () {\n  function SenangWebsChatbot(knowledgeBase) {\n    var botMetadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var apiConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, SenangWebsChatbot);\n    this.knowledgeBase = knowledgeBase;\n    this.currentNode = null;\n    this.chatHistory = [];\n    this.botMetadata = {\n      botName: botMetadata.botName || \"Bot\",\n      themeColor: botMetadata.themeColor || \"#007bff\",\n      timestamp: new Date().toISOString()\n    };\n\n    // API Configuration\n    this.apiConfig = apiConfig;\n    this.mode = (apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.mode) || \"keyword-only\"; // 'keyword-only', 'ai-only', 'hybrid'\n    this.streamingEnabled = (apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.streaming) !== false;\n    this.aiResponseInProgress = false;\n    this.hybridThreshold = (apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.hybridThreshold) || 0.3; // Lower default for better keyword matching\n\n    // Initialize API client and context manager if API is configured\n    if (apiConfig && apiConfig.apiKey) {\n      try {\n        // Check if OpenRouterAPI class is available\n        if (typeof OpenRouterAPI !== \"undefined\") {\n          this.apiClient = new OpenRouterAPI(apiConfig);\n        } else {\n          console.error(\"[SWC] OpenRouterAPI class not found. Please include openrouter-client.js\");\n          this.apiClient = null;\n        }\n\n        // Check if ContextManager class is available\n        if (typeof ContextManager !== \"undefined\") {\n          this.contextManager = new ContextManager({\n            systemPrompt: apiConfig.systemPrompt || \"You are a helpful assistant.\",\n            maxMessages: apiConfig.contextMaxMessages || 10,\n            maxTokens: apiConfig.contextMaxTokens || 2000,\n            debug: apiConfig.debug || false\n          });\n        } else {\n          console.error(\"[SWC] ContextManager class not found. Please include context-manager.js\");\n          this.contextManager = null;\n        }\n      } catch (error) {\n        console.error(\"[SWC] Error initializing API components:\", error);\n        this.apiClient = null;\n        this.contextManager = null;\n      }\n    } else {\n      this.apiClient = null;\n      this.contextManager = null;\n    }\n  }\n  return _createClass(SenangWebsChatbot, [{\n    key: \"init\",\n    value: function init() {\n      this.currentNode = this.knowledgeBase.find(function (node) {\n        return node.id === \"welcome\";\n      }) || this.knowledgeBase[0];\n      var response = {\n        reply: this.currentNode.reply,\n        options: this.currentNode.options\n      };\n\n      // Add welcome message to history\n      this.addToHistory(\"bot\", this.currentNode.reply, this.currentNode.id, this.currentNode.options);\n      return response;\n    }\n  }, {\n    key: \"addToHistory\",\n    value: function addToHistory(type, content) {\n      var nodeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var source = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"keyword\";\n      var modelInfo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var message = {\n        id: \"msg-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 11)),\n        timestamp: new Date().toISOString(),\n        type: type,\n        content: content,\n        source: source // 'keyword', 'api', or 'fallback'\n      };\n      if (type === \"bot\") {\n        message.nodeId = nodeId;\n        if (options && options.length > 0) {\n          message.options = options;\n        }\n        if (modelInfo) {\n          message.model = modelInfo.model;\n        }\n      }\n      this.chatHistory.push(message);\n    }\n  }, {\n    key: \"handleInput\",\n    value: function () {\n      var _handleInput = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(input) {\n        var _this = this;\n        var callbacks,\n          lowercaseInput,\n          words,\n          keywordScores,\n          bestMatch,\n          maxScore,\n          confidence,\n          fallbackReply,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              callbacks = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              lowercaseInput = input.toLowerCase();\n              words = lowercaseInput.split(/\\s+/); // Add user message to history\n              this.addToHistory(\"user\", input);\n\n              // Add user message to context if API is enabled\n              if (this.contextManager) {\n                this.contextManager.addMessage(\"user\", input);\n              }\n\n              // Keyword matching\n              keywordScores = {};\n              this.knowledgeBase.forEach(function (node) {\n                keywordScores[node.id] = 0;\n                node.keyword.forEach(function (keyword) {\n                  var lowercaseKeyword = keyword.toLowerCase();\n                  words.forEach(function (word) {\n                    if (word.includes(lowercaseKeyword) || lowercaseKeyword.includes(word)) {\n                      keywordScores[node.id]++;\n                    }\n                  });\n                });\n              });\n              bestMatch = null;\n              maxScore = 0;\n              Object.entries(keywordScores).forEach(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                  nodeId = _ref2[0],\n                  score = _ref2[1];\n                if (score > maxScore) {\n                  maxScore = score;\n                  bestMatch = _this.knowledgeBase.find(function (node) {\n                    return node.id === nodeId;\n                  });\n                }\n              });\n\n              // Calculate confidence score (0-1 range)\n              // If we have a keyword match, confidence should be high enough to use it in hybrid mode\n              // Confidence increases with number of matching keywords\n              confidence = 0;\n              if (maxScore > 0) {\n                // Base confidence of 0.5 for any match, plus 0.1 per additional match (capped at 1.0)\n                confidence = Math.min(0.5 + (maxScore - 1) * 0.1, 1.0);\n              }\n\n              // Debug logging for hybrid mode\n              if (this.mode === \"hybrid\") {\n                console.log(\"[SWC Hybrid Debug]\", {\n                  input: input,\n                  bestMatch: bestMatch ? bestMatch.id : null,\n                  maxScore: maxScore,\n                  confidence: confidence,\n                  threshold: this.hybridThreshold,\n                  willUseAI: !bestMatch || confidence < this.hybridThreshold\n                });\n              }\n\n              // Mode-based routing\n              if (!(this.mode === \"ai-only\" && this.apiClient)) {\n                _context.next = 19;\n                break;\n              }\n              _context.next = 16;\n              return this.handleAIResponse(input, callbacks);\n            case 16:\n              return _context.abrupt(\"return\", _context.sent);\n            case 19:\n              if (!(this.mode === \"hybrid\" && this.apiClient)) {\n                _context.next = 26;\n                break;\n              }\n              if (!(!bestMatch || confidence < this.hybridThreshold)) {\n                _context.next = 24;\n                break;\n              }\n              _context.next = 23;\n              return this.handleAIResponse(input, callbacks);\n            case 23:\n              return _context.abrupt(\"return\", _context.sent);\n            case 24:\n              _context.next = 27;\n              break;\n            case 26:\n              if (this.mode === \"keyword-only\" || !this.apiClient) {\n                // Fall through to keyword response\n              }\n            case 27:\n              if (!bestMatch) {\n                _context.next = 34;\n                break;\n              }\n              this.currentNode = bestMatch;\n              // Add bot response to history\n              this.addToHistory(\"bot\", bestMatch.reply, bestMatch.id, bestMatch.options, \"keyword\");\n\n              // Add to context if API is enabled\n              if (this.contextManager) {\n                this.contextManager.addMessage(\"assistant\", bestMatch.reply);\n              }\n              return _context.abrupt(\"return\", {\n                reply: bestMatch.reply,\n                options: bestMatch.options,\n                source: \"keyword\",\n                confidence: confidence\n              });\n            case 34:\n              if (!(this.mode === \"hybrid\" && this.apiClient)) {\n                _context.next = 38;\n                break;\n              }\n              _context.next = 37;\n              return this.handleAIResponse(input, callbacks);\n            case 37:\n              return _context.abrupt(\"return\", _context.sent);\n            case 38:\n              // Fallback response\n              fallbackReply = \"I'm sorry, I didn't understand that. Can you please rephrase?\";\n              this.addToHistory(\"bot\", fallbackReply, null, null, \"fallback\");\n              return _context.abrupt(\"return\", {\n                reply: fallbackReply,\n                options: null,\n                source: \"fallback\"\n              });\n            case 41:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function handleInput(_x) {\n        return _handleInput.apply(this, arguments);\n      }\n      return handleInput;\n    }()\n    /**\r\n     * Handle AI-powered response using OpenRouter API\r\n     * @param {string} input - User input\r\n     * @param {Object} callbacks - Callbacks for streaming: onStart, onChunk, onComplete, onError\r\n     * @returns {Promise<Object>} Response object\r\n     */\n  }, {\n    key: \"handleAIResponse\",\n    value: (function () {\n      var _handleAIResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input) {\n        var _this2 = this;\n        var callbacks,\n          messages,\n          fullResponse,\n          onStartCalled,\n          result,\n          errorMessage,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              callbacks = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              if (this.apiClient) {\n                _context2.next = 4;\n                break;\n              }\n              console.error(\"[SWC] API client not initialized\");\n              return _context2.abrupt(\"return\", {\n                reply: \"AI features are not configured properly.\",\n                options: null,\n                source: \"error\"\n              });\n            case 4:\n              if (!this.aiResponseInProgress) {\n                _context2.next = 7;\n                break;\n              }\n              console.warn(\"[SWC] AI response already in progress\");\n              return _context2.abrupt(\"return\", {\n                reply: \"Please wait for the current response to complete.\",\n                options: null,\n                source: \"error\"\n              });\n            case 7:\n              this.aiResponseInProgress = true;\n              _context2.prev = 8;\n              if (this.contextManager) {\n                _context2.next = 11;\n                break;\n              }\n              throw new Error(\"Context manager not initialized\");\n            case 11:\n              messages = this.contextManager.getContext(true); // onStart callback will be triggered on first chunk, not here\n              fullResponse = \"\";\n              onStartCalled = false; // Send message with streaming\n              _context2.next = 16;\n              return this.apiClient.sendMessage(messages,\n              // onChunk callback\n              function (chunk) {\n                // Trigger onStart on first chunk (when streaming actually begins)\n                if (!onStartCalled && callbacks.onStart) {\n                  callbacks.onStart();\n                  onStartCalled = true;\n                }\n                fullResponse = chunk.fullContent;\n                if (callbacks.onChunk) {\n                  callbacks.onChunk(chunk);\n                }\n              },\n              // onComplete callback\n              function (response) {\n                // Add AI response to history\n                var modelInfo = _this2.apiClient.getModelInfo();\n                _this2.addToHistory(\"bot\", response.content, null, null, \"api\", modelInfo);\n\n                // Add to context\n                if (_this2.contextManager) {\n                  _this2.contextManager.addMessage(\"assistant\", response.content);\n                }\n                if (callbacks.onComplete) {\n                  callbacks.onComplete(response);\n                }\n              },\n              // onError callback\n              function (error) {\n                console.error(\"[SWC] AI response error:\", error);\n                if (callbacks.onError) {\n                  callbacks.onError(error);\n                }\n              });\n            case 16:\n              result = _context2.sent;\n              this.aiResponseInProgress = false;\n              return _context2.abrupt(\"return\", {\n                reply: result.content,\n                options: null,\n                source: \"api\",\n                model: result.model\n              });\n            case 21:\n              _context2.prev = 21;\n              _context2.t0 = _context2[\"catch\"](8);\n              this.aiResponseInProgress = false;\n              console.error(\"[SWC] Error in handleAIResponse:\", _context2.t0);\n\n              // Add error to history\n              errorMessage = this._getErrorMessage(_context2.t0);\n              this.addToHistory(\"bot\", errorMessage, null, null, \"error\");\n              if (callbacks.onError) {\n                callbacks.onError(_context2.t0);\n              }\n              return _context2.abrupt(\"return\", {\n                reply: errorMessage,\n                options: null,\n                source: \"error\"\n              });\n            case 29:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[8, 21]]);\n      }));\n      function handleAIResponse(_x2) {\n        return _handleAIResponse.apply(this, arguments);\n      }\n      return handleAIResponse;\n    }()\n    /**\r\n     * Cancel ongoing AI response\r\n     */\n    )\n  }, {\n    key: \"cancelAIResponse\",\n    value: function cancelAIResponse() {\n      if (this.apiClient && this.aiResponseInProgress) {\n        this.apiClient.cancel();\n        this.aiResponseInProgress = false;\n        return true;\n      }\n      return false;\n    }\n\n    /**\r\n     * Get user-friendly error message\r\n     * @private\r\n     */\n  }, {\n    key: \"_getErrorMessage\",\n    value: function _getErrorMessage(error) {\n      if (error.message.includes(\"Invalid API key\")) {\n        return \"âš ï¸ API authentication failed. Please check your API key configuration.\";\n      } else if (error.message.includes(\"Rate limit\")) {\n        return \"âš ï¸ Too many requests. Please wait a moment and try again.\";\n      } else if (error.message.includes(\"cancelled\")) {\n        return \"Response cancelled.\";\n      } else if (error.message.includes(\"service is temporarily unavailable\")) {\n        return \"âš ï¸ The AI service is temporarily unavailable. Please try again later.\";\n      } else {\n        return \"\\u26A0\\uFE0F An error occurred: \".concat(error.message);\n      }\n    }\n\n    /**\r\n     * Enhance prompt with knowledge base (RAG approach)\r\n     * @private\r\n     */\n  }, {\n    key: \"_enhancePromptWithKnowledge\",\n    value: function _enhancePromptWithKnowledge(input) {\n      // Find relevant knowledge base entries\n      var relevantNodes = [];\n      var lowercaseInput = input.toLowerCase();\n      this.knowledgeBase.forEach(function (node) {\n        node.keyword.forEach(function (keyword) {\n          if (lowercaseInput.includes(keyword.toLowerCase())) {\n            relevantNodes.push(node);\n          }\n        });\n      });\n      if (relevantNodes.length > 0) {\n        var knowledge = relevantNodes.map(function (node) {\n          return \"Topic: \".concat(node.id, \"\\nInformation: \").concat(node.reply);\n        }).join(\"\\n\\n\");\n        this.contextManager.injectKnowledge(knowledge);\n      }\n    }\n\n    /**\r\n     * Get API configuration and status\r\n     * @returns {Object} API status information\r\n     */\n  }, {\n    key: \"getAPIStatus\",\n    value: function getAPIStatus() {\n      return {\n        enabled: !!this.apiClient,\n        mode: this.mode,\n        streaming: this.streamingEnabled,\n        model: this.apiClient ? this.apiClient.getModelInfo() : null,\n        contextStats: this.contextManager ? this.contextManager.getStats() : null,\n        responseInProgress: this.aiResponseInProgress\n      };\n    }\n  }, {\n    key: \"handleOptionSelection\",\n    value: function handleOptionSelection(replyId) {\n      var nextNode = this.knowledgeBase.find(function (node) {\n        return node.id === replyId;\n      });\n      if (nextNode) {\n        this.currentNode = nextNode;\n        // Add bot response to history\n        this.addToHistory(\"bot\", nextNode.reply, nextNode.id, nextNode.options);\n        return {\n          reply: nextNode.reply,\n          options: nextNode.options\n        };\n      } else {\n        var fallbackReply = \"I'm sorry, I couldn't find the appropriate response. How else can I assist you?\";\n        // Add fallback response to history\n        this.addToHistory(\"bot\", fallbackReply, null, null);\n        return {\n          reply: fallbackReply,\n          options: null\n        };\n      }\n    }\n\n    // Phase 1.2: Export History\n  }, {\n    key: \"exportHistory\",\n    value: function exportHistory() {\n      var historyData = {\n        version: \"2.0\",\n        // Updated version for API support\n        timestamp: new Date().toISOString(),\n        botName: this.botMetadata.botName,\n        themeColor: this.botMetadata.themeColor,\n        messages: this.chatHistory,\n        currentNodeId: this.currentNode ? this.currentNode.id : null,\n        // API metadata\n        mode: this.mode,\n        apiEnabled: !!this.apiClient,\n        apiConfig: this.apiClient ? {\n          model: this.apiClient.model,\n          lastUsed: new Date().toISOString()\n        } : null\n      };\n      return JSON.stringify(historyData, null, 2);\n    }\n  }, {\n    key: \"getCurrentState\",\n    value: function getCurrentState() {\n      return {\n        currentNodeId: this.currentNode ? this.currentNode.id : null,\n        messageCount: this.chatHistory.length,\n        lastMessageTimestamp: this.chatHistory.length > 0 ? this.chatHistory[this.chatHistory.length - 1].timestamp : null\n      };\n    }\n\n    // Phase 1.3: Load History\n  }, {\n    key: \"loadHistory\",\n    value: function loadHistory(historyData) {\n      var _this3 = this;\n      try {\n        // Parse if string, use directly if object\n        var data = typeof historyData === \"string\" ? JSON.parse(historyData) : historyData;\n\n        // Validate structure\n        if (!data.version || !data.messages || !Array.isArray(data.messages)) {\n          throw new Error(\"Invalid history format: missing required fields\");\n        }\n\n        // Check version compatibility\n        if (!data.version.startsWith(\"1.\") && !data.version.startsWith(\"2.\")) {\n          console.warn(\"History version \".concat(data.version, \" may not be fully compatible\"));\n        }\n\n        // Update bot metadata if present\n        if (data.botName) this.botMetadata.botName = data.botName;\n        if (data.themeColor) this.botMetadata.themeColor = data.themeColor;\n\n        // Restore chat history\n        this.chatHistory = data.messages;\n\n        // Restore current node state\n        if (data.currentNodeId) {\n          var node = this.knowledgeBase.find(function (n) {\n            return n.id === data.currentNodeId;\n          });\n          if (node) {\n            this.currentNode = node;\n          }\n        }\n\n        // Restore API context if available\n        if (this.contextManager && data.messages) {\n          this.contextManager.clear();\n          data.messages.forEach(function (msg) {\n            if (msg.type === \"user\") {\n              _this3.contextManager.addMessage(\"user\", msg.content);\n            } else if (msg.type === \"bot\") {\n              _this3.contextManager.addMessage(\"assistant\", msg.content);\n            }\n          });\n        }\n        return {\n          success: true,\n          messageCount: this.chatHistory.length,\n          messages: this.chatHistory\n        };\n      } catch (error) {\n        console.error(\"Error loading history:\", error);\n        return {\n          success: false,\n          error: error.message,\n          messages: []\n        };\n      }\n    }\n\n    // Phase 1.4: Clear History\n  }, {\n    key: \"clearHistory\",\n    value: function clearHistory() {\n      this.chatHistory = [];\n      this.currentNode = this.knowledgeBase.find(function (node) {\n        return node.id === \"welcome\";\n      }) || this.knowledgeBase[0];\n\n      // Add welcome message to fresh history\n      if (this.currentNode) {\n        this.addToHistory(\"bot\", this.currentNode.reply, this.currentNode.id, this.currentNode.options);\n      }\n      return {\n        reply: this.currentNode ? this.currentNode.reply : \"\",\n        options: this.currentNode ? this.currentNode.options : null\n      };\n    }\n\n    // Phase 4.1: Get History (returns object not string)\n  }, {\n    key: \"getHistory\",\n    value: function getHistory() {\n      return {\n        version: \"2.0\",\n        timestamp: new Date().toISOString(),\n        botName: this.botMetadata.botName,\n        themeColor: this.botMetadata.themeColor,\n        messages: this.chatHistory,\n        currentNodeId: this.currentNode ? this.currentNode.id : null,\n        mode: this.mode,\n        apiEnabled: !!this.apiClient\n      };\n    }\n  }]);\n}(); // Default knowledge base\nvar defaultKnowledgeBase = [{\n  id: \"welcome\",\n  keyword: [\"hello\", \"hi\", \"hey\"],\n  reply: 'Welcome! How can I assist you <b>today?</b> <a href=\"https://senangwebs.com\">senangwebs.com</a>',\n  options: [{\n    label: \"Get Help\",\n    reply_id: \"help\"\n  }, {\n    label: \"End Chat\",\n    reply_id: \"goodbye\"\n  }]\n}, {\n  id: \"help\",\n  keyword: [\"help\", \"support\", \"assist\"],\n  reply: \"Sure, I can help! What do you need assistance with?\",\n  options: [{\n    label: \"Product Information\",\n    reply_id: \"product\"\n  }, {\n    label: \"Billing\",\n    reply_id: \"billing\"\n  }, {\n    label: \"Technical Support\",\n    reply_id: \"tech_support\"\n  }]\n}, {\n  id: \"product\",\n  keyword: [\"product\", \"information\"],\n  reply: \"Our product is designed to make your life easier. Would you like to know more about its features or pricing?\",\n  options: [{\n    label: \"Features\",\n    reply_id: \"features\"\n  }, {\n    label: \"Pricing\",\n    reply_id: \"pricing\"\n  }]\n}, {\n  id: \"billing\",\n  keyword: [\"billing\", \"payment\", \"invoice\"],\n  reply: \"For billing inquiries, please visit our billing portal or contact our finance department at billing@example.com.\",\n  options: [{\n    label: \"Back to Help\",\n    reply_id: \"help\"\n  }, {\n    label: \"End Chat\",\n    reply_id: \"goodbye\"\n  }]\n}, {\n  id: \"tech_support\",\n  keyword: [\"technical\", \"support\", \"issue\"],\n  reply: \"For technical support, please describe your issue in detail and well do our best to assist you.\"\n}, {\n  id: \"features\",\n  keyword: [\"features\", \"functionality\"],\n  reply: \"Our product offers cutting-edge features including AI-powered analytics, real-time collaboration, and seamless integration with popular tools.\",\n  options: [{\n    label: \"Back to Product Info\",\n    reply_id: \"product\"\n  }, {\n    label: \"End Chat\",\n    reply_id: \"goodbye\"\n  }]\n}, {\n  id: \"pricing\",\n  keyword: [\"pricing\", \"cost\", \"plans\"],\n  reply: \"We offer flexible pricing plans starting at $9.99/month. For detailed pricing information, please visit our website or contact our sales team.\",\n  options: [{\n    label: \"Back to Product Info\",\n    reply_id: \"product\"\n  }, {\n    label: \"End Chat\",\n    reply_id: \"goodbye\"\n  }]\n}, {\n  id: \"goodbye\",\n  keyword: [\"bye\", \"goodbye\", \"end\"],\n  reply: \"Thank you for chatting with us. Have a great day!\",\n  options: [{\n    label: \"Restart Chat\",\n    reply_id: \"welcome\"\n  }]\n}];\nfunction createChatbotUI(containerElement, themeColor, botName, chatDisplayStyle) {\n  var chatDisplay = document.createElement(\"div\");\n  chatDisplay.className = \"swc-chat-display \".concat(chatDisplayStyle === \"modern\" ? \"swc-modern\" : \"swc-classic\");\n  var inputContainer = document.createElement(\"div\");\n  inputContainer.className = \"swc-input-container\";\n  var userInput = document.createElement(\"input\");\n  userInput.type = \"text\";\n  userInput.className = \"swc-user-input\";\n  userInput.placeholder = \"Type your message...\";\n  var sendButton = document.createElement(\"button\");\n  sendButton.className = \"swc-send-button\";\n  sendButton.textContent = \"Send\";\n  var optionsContainer = document.createElement(\"div\");\n  optionsContainer.className = \"swc-options-container\";\n  inputContainer.appendChild(userInput);\n  inputContainer.appendChild(sendButton);\n  var typingIndicator = document.createElement(\"div\");\n  typingIndicator.className = \"swc-typing-indicator\";\n  typingIndicator.innerHTML = \"<span></span><span></span><span></span>\";\n  containerElement.appendChild(chatDisplay);\n  containerElement.appendChild(optionsContainer);\n  containerElement.appendChild(inputContainer);\n\n  // Apply theme color and bot name\n  containerElement.style.setProperty(\"--swc-theme-color\", themeColor);\n  containerElement.style.setProperty(\"--swc-bot-name\", \"\\\"\".concat(botName, \"\\\"\"));\n  return {\n    chatDisplay: chatDisplay,\n    userInput: userInput,\n    sendButton: sendButton,\n    optionsContainer: optionsContainer,\n    typingIndicator: typingIndicator,\n    inputContainer: inputContainer\n  };\n}\nfunction initializeChatbot() {\n  var customKnowledgeBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var chatbotElements = document.querySelectorAll(\"[data-swc]\");\n  chatbotElements.forEach(function (element) {\n    var themeColor = element.getAttribute(\"data-swc-theme-color\") || \"#007bff\";\n    var botName = element.getAttribute(\"data-swc-bot-name\") || \"Bot\";\n    var chatDisplayStyle = element.getAttribute(\"data-swc-chat-display\") || \"classic\";\n    var replyDuration = parseInt(element.getAttribute(\"data-swc-reply-duration\")) || 0;\n    var loadHistory = element.getAttribute(\"data-swc-load\");\n\n    // Parse API configuration from data attributes\n    var apiMode = element.getAttribute(\"data-swc-api-mode\");\n    var apiKey = element.getAttribute(\"data-swc-api-key\");\n    var apiModel = element.getAttribute(\"data-swc-api-model\");\n    var apiStreaming = element.getAttribute(\"data-swc-api-streaming\");\n    var apiMaxTokens = element.getAttribute(\"data-swc-api-max-tokens\");\n    var apiTemperature = element.getAttribute(\"data-swc-api-temperature\");\n    var systemPrompt = element.getAttribute(\"data-swc-system-prompt\");\n    var contextMaxMessages = element.getAttribute(\"data-swc-context-max-messages\");\n    var apiBaseURL = element.getAttribute(\"data-swc-api-base-url\");\n    var hybridThreshold = element.getAttribute(\"data-swc-hybrid-threshold\");\n\n    // Build API config object if API key is provided\n    var apiConfig = null;\n    if (apiKey && apiMode !== \"keyword-only\") {\n      apiConfig = {\n        apiKey: apiKey,\n        mode: apiMode || \"hybrid\",\n        model: apiModel || \"openai/gpt-3.5-turbo\",\n        streaming: apiStreaming !== \"false\",\n        maxTokens: parseInt(apiMaxTokens) || 500,\n        temperature: parseFloat(apiTemperature) || 0.7,\n        systemPrompt: systemPrompt || \"You are a helpful assistant.\",\n        contextMaxMessages: parseInt(contextMaxMessages) || 10,\n        baseURL: apiBaseURL,\n        hybridThreshold: parseFloat(hybridThreshold) || 0.3,\n        siteName: botName,\n        siteUrl: window.location.origin\n      };\n\n      // Show warning about client-side API key\n      if (!apiBaseURL || apiBaseURL.includes(\"openrouter.ai\")) {\n        console.warn(\"[SWC] âš ï¸ API key is exposed in client-side code. For production, use a server-side proxy.\");\n      }\n    }\n\n    // Phase 2.1: Create chatbot instance with metadata and API config\n    var chatbot = new SenangWebsChatbot(customKnowledgeBase || defaultKnowledgeBase, {\n      botName: botName,\n      themeColor: themeColor\n    }, apiConfig);\n\n    // Phase 2.1: Store instance on element for external access\n    element.chatbotInstance = chatbot;\n    var _createChatbotUI = createChatbotUI(element, themeColor, botName, chatDisplayStyle),\n      chatDisplay = _createChatbotUI.chatDisplay,\n      userInput = _createChatbotUI.userInput,\n      sendButton = _createChatbotUI.sendButton,\n      optionsContainer = _createChatbotUI.optionsContainer,\n      typingIndicator = _createChatbotUI.typingIndicator,\n      inputContainer = _createChatbotUI.inputContainer;\n\n    // HTML sanitization helper to prevent XSS attacks\n    function escapeHTML(str) {\n      var div = document.createElement(\"div\");\n      div.textContent = str;\n      return div.innerHTML;\n    }\n\n    // Check if content appears to be safe HTML (from bot responses)\n    function isSafeHTML(content) {\n      // Bot replies from knowledge base may contain safe HTML like <b>, <a>, etc.\n      // We'll allow content that doesn't contain script tags or event handlers\n      var dangerousPatterns = /<script|javascript:|on\\w+\\s*=/i;\n      return !dangerousPatterns.test(content);\n    }\n\n    // Phase 2.3: Render message helper function\n    function renderMessage(message) {\n      var messageElement = document.createElement(\"div\");\n      messageElement.className = \"swc-message swc-\".concat(message.type, \"-message\");\n      // Sanitize user messages, allow safe HTML in bot messages\n      if (message.type === \"user\") {\n        messageElement.textContent = message.content;\n      } else if (isSafeHTML(message.content)) {\n        messageElement.innerHTML = message.content;\n      } else {\n        messageElement.textContent = message.content;\n      }\n      chatDisplay.appendChild(messageElement);\n    }\n\n    // Phase 2.3: Clear display helper\n    function clearDisplay() {\n      chatDisplay.innerHTML = \"\";\n      optionsContainer.innerHTML = \"\";\n      optionsContainer.style.display = \"none\";\n    }\n    function displayBotMessage(message, options) {\n      var isStreaming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"keyword\";\n      removeTypingIndicator();\n      var messageElement = document.createElement(\"div\");\n      messageElement.className = \"swc-message swc-bot-message \".concat(isStreaming ? \"swc-streaming\" : \"\", \" \").concat(source === \"api\" ? \"swc-ai-message\" : \"\");\n      // Sanitize content: for API responses, escape HTML; for keyword responses, allow safe HTML\n      if (source === \"api\" || !isSafeHTML(message)) {\n        messageElement.textContent = message;\n      } else {\n        messageElement.innerHTML = message;\n      }\n      messageElement.setAttribute(\"data-message-id\", \"msg-\".concat(Date.now()));\n      chatDisplay.appendChild(messageElement);\n      smoothScrollToBottom(chatDisplay);\n      optionsContainer.innerHTML = \"\";\n      if (options && options.length > 0) {\n        optionsContainer.style.display = \"flex\";\n        options.forEach(function (option) {\n          var button = document.createElement(\"button\");\n          button.textContent = option.label;\n          button.onclick = function () {\n            return handleOptionClick(option.reply_id);\n          };\n          optionsContainer.appendChild(button);\n        });\n      } else {\n        optionsContainer.style.display = \"none\";\n      }\n      return messageElement;\n    }\n\n    // Create stop button for AI streaming\n    function createStopButton() {\n      var stopBtn = document.createElement(\"button\");\n      stopBtn.className = \"swc-stop-button\";\n      stopBtn.innerHTML = \"Stop\";\n      stopBtn.onclick = function () {\n        chatbot.cancelAIResponse();\n        stopBtn.remove();\n        enableUserInput();\n      };\n      return stopBtn;\n    }\n    function handleUserInput() {\n      return _handleUserInput.apply(this, arguments);\n    }\n    function _handleUserInput() {\n      _handleUserInput = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var message, userMessageElement, isAIEnabled, stopButton;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              message = userInput.value.trim();\n              if (message) {\n                userMessageElement = document.createElement(\"div\");\n                userMessageElement.className = \"swc-message swc-user-message\";\n                // Use textContent to prevent XSS from user input\n                userMessageElement.textContent = message;\n                chatDisplay.appendChild(userMessageElement);\n                smoothScrollToBottom(chatDisplay);\n                userInput.value = \"\";\n                disableUserInput();\n                showTypingIndicator();\n\n                // Check if this will be an AI response\n                isAIEnabled = chatbot.mode !== \"keyword-only\" && chatbot.apiClient;\n                stopButton = null;\n                if (isAIEnabled && replyDuration === 0) {\n                  // For AI responses, add delay then proceed\n                  setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    var streamingMessage, streamStopButton, response;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) switch (_context3.prev = _context3.next) {\n                        case 0:\n                          // Typing indicator stays visible until onStart is triggered\n                          // Create streaming message element\n                          streamingMessage = null;\n                          streamStopButton = null;\n                          _context3.next = 4;\n                          return chatbot.handleInput(message, {\n                            onStart: function onStart() {\n                              // Remove typing indicator now that streaming is starting\n                              removeTypingIndicator();\n                              // Create message element for streaming\n                              streamingMessage = displayBotMessage(\"\", null, true, \"api\");\n\n                              // Add stop button if streaming\n                              if (chatbot.streamingEnabled) {\n                                streamStopButton = createStopButton();\n                                inputContainer.insertBefore(streamStopButton, inputContainer.firstChild);\n                              }\n                            },\n                            onChunk: function onChunk(chunk) {\n                              // Update streaming message with escaped content to prevent XSS\n                              if (streamingMessage) {\n                                requestAnimationFrame(function () {\n                                  streamingMessage.textContent = chunk.fullContent;\n                                  smoothScrollToBottom(chatDisplay);\n                                });\n                              }\n                            },\n                            onComplete: function onComplete(result) {\n                              // Remove streaming class\n                              if (streamingMessage) {\n                                streamingMessage.classList.remove(\"swc-streaming\");\n                              }\n                              // Remove stop button\n                              if (streamStopButton) {\n                                streamStopButton.remove();\n                              }\n                              enableUserInput();\n                            },\n                            onError: function onError(error) {\n                              // Remove stop button\n                              if (streamStopButton) {\n                                streamStopButton.remove();\n                              }\n                              // Display error\n                              if (streamingMessage) {\n                                streamingMessage.classList.remove(\"swc-streaming\");\n                                streamingMessage.classList.add(\"swc-error-message\");\n                              }\n                              enableUserInput();\n                            }\n                          });\n                        case 4:\n                          response = _context3.sent;\n                          // If not streaming or error occurred, display normally\n                          if (!streamingMessage) {\n                            displayBotMessage(response.reply, response.options, false, response.source);\n                            enableUserInput();\n                          }\n                        case 6:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }, _callee3);\n                  })), 500);\n                } else {\n                  // Keyword-only mode or delay is set\n                  setTimeout(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                    var response;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return chatbot.handleInput(message);\n                        case 2:\n                          response = _context4.sent;\n                          displayBotMessage(response.reply, response.options, false, response.source);\n                          enableUserInput();\n                        case 5:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }, _callee4);\n                  })), replyDuration);\n                }\n              }\n            case 2:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      return _handleUserInput.apply(this, arguments);\n    }\n    function handleOptionClick(replyId) {\n      disableUserInput();\n      showTypingIndicator();\n      // Use minimum 500ms delay for option clicks to show typing indicator\n      var optionDelay = Math.max(replyDuration, 500);\n      setTimeout(function () {\n        var response = chatbot.handleOptionSelection(replyId);\n        displayBotMessage(response.reply, response.options);\n        enableUserInput();\n      }, optionDelay);\n    }\n    function disableUserInput() {\n      userInput.disabled = true;\n      sendButton.disabled = true;\n    }\n    function enableUserInput() {\n      userInput.disabled = false;\n      sendButton.disabled = false;\n    }\n    function showTypingIndicator() {\n      removeTypingIndicator(); // Remove any existing indicator first\n      chatDisplay.appendChild(typingIndicator);\n      smoothScrollToBottom(chatDisplay);\n    }\n    function removeTypingIndicator() {\n      if (typingIndicator.parentNode === chatDisplay) {\n        chatDisplay.removeChild(typingIndicator);\n      }\n    }\n    function smoothScrollToBottom(element) {\n      var targetScrollTop = element.scrollHeight - element.clientHeight;\n      var startScrollTop = element.scrollTop;\n      var distance = targetScrollTop - startScrollTop;\n      var duration = 300; // ms\n      var start = null;\n      function step(timestamp) {\n        if (!start) start = timestamp;\n        var progress = timestamp - start;\n        element.scrollTop = easeInOutCubic(progress, startScrollTop, distance, duration);\n        if (progress < duration) {\n          window.requestAnimationFrame(step);\n        }\n      }\n      window.requestAnimationFrame(step);\n    }\n    function easeInOutCubic(t, b, c, d) {\n      t /= d / 2;\n      if (t < 1) return c / 2 * t * t * t + b;\n      t -= 2;\n      return c / 2 * (t * t * t + 2) + b;\n    }\n    sendButton.addEventListener(\"click\", handleUserInput);\n    userInput.addEventListener(\"keypress\", function (e) {\n      if (e.key === \"Enter\") {\n        handleUserInput();\n      }\n    });\n\n    // Phase 4.2: Enhanced clearHistory with UI update and event\n    var originalClearHistory = chatbot.clearHistory.bind(chatbot);\n    chatbot.clearHistory = function () {\n      var result = originalClearHistory();\n      clearDisplay();\n      displayBotMessage(result.reply, result.options);\n\n      // Dispatch custom event\n      element.dispatchEvent(new CustomEvent(\"swc:history-cleared\", {\n        detail: {\n          timestamp: new Date().toISOString()\n        }\n      }));\n      return result;\n    };\n\n    // Phase 4.2: Enhanced exportHistory with event\n    var originalExportHistory = chatbot.exportHistory.bind(chatbot);\n    chatbot.exportHistory = function () {\n      var historyJSON = originalExportHistory();\n\n      // Dispatch custom event\n      element.dispatchEvent(new CustomEvent(\"swc:history-exported\", {\n        detail: {\n          messageCount: chatbot.chatHistory.length,\n          historyJSON: historyJSON,\n          timestamp: new Date().toISOString()\n        }\n      }));\n      return historyJSON;\n    };\n\n    // Phase 4.2: Enhanced loadHistory with UI update and event\n    var originalLoadHistory = chatbot.loadHistory.bind(chatbot);\n    chatbot.loadHistory = function (historyData) {\n      var result = originalLoadHistory(historyData);\n      if (result.success) {\n        clearDisplay();\n\n        // Render all messages from history\n        result.messages.forEach(function (msg) {\n          renderMessage(msg);\n        });\n\n        // Render options from last message if present\n        if (result.messages.length > 0) {\n          var lastMessage = result.messages[result.messages.length - 1];\n          if (lastMessage.options && lastMessage.options.length > 0) {\n            optionsContainer.style.display = \"flex\";\n            lastMessage.options.forEach(function (option) {\n              var button = document.createElement(\"button\");\n              button.textContent = option.label;\n              button.onclick = function () {\n                return handleOptionClick(option.reply_id);\n              };\n              optionsContainer.appendChild(button);\n            });\n          }\n        }\n        smoothScrollToBottom(chatDisplay);\n\n        // Dispatch custom event\n        element.dispatchEvent(new CustomEvent(\"swc:history-loaded\", {\n          detail: {\n            messageCount: result.messageCount,\n            timestamp: new Date().toISOString()\n          }\n        }));\n      } else {\n        console.error(\"Failed to load history:\", result.error);\n      }\n      return result;\n    };\n\n    // Phase 3: Declarative History Loading\n    if (loadHistory) {\n      // Check if it's a URL/file path or JSON string\n      var isUrl = loadHistory.startsWith(\"http://\") || loadHistory.startsWith(\"https://\") || loadHistory.startsWith(\"./\") || loadHistory.startsWith(\"../\") || loadHistory.endsWith(\".json\");\n      if (isUrl) {\n        // Phase 3.2: Load from external file\n        fetch(loadHistory).then(function (response) {\n          if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n          }\n          return response.json();\n        }).then(function (data) {\n          chatbot.loadHistory(data);\n        })[\"catch\"](function (error) {\n          console.error(\"Error loading history from file:\", error);\n          // Fallback to default initialization\n          var initialResponse = chatbot.init();\n          displayBotMessage(initialResponse.reply, initialResponse.options);\n        });\n      } else {\n        // Phase 3.3: Load from inline JSON string\n        try {\n          var data = JSON.parse(loadHistory);\n          chatbot.loadHistory(data);\n        } catch (error) {\n          console.error(\"Error parsing inline history JSON:\", error);\n          // Fallback to default initialization\n          var initialResponse = chatbot.init();\n          displayBotMessage(initialResponse.reply, initialResponse.options);\n        }\n      }\n    } else {\n      // Initialize the chatbot normally\n      var _initialResponse = chatbot.init();\n      displayBotMessage(_initialResponse.reply, _initialResponse.options);\n    }\n  });\n}\n\n// Export the main class and functions\n\n\n// Make initializeChatbot globally accessible\nif (typeof window !== \"undefined\") {\n  window.initializeChatbot = initializeChatbot;\n\n  // Auto-initialize on DOMContentLoaded\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      initializeChatbot();\n    });\n  } else {\n    // DOM already loaded\n    initializeChatbot();\n  }\n}\n\n//# sourceURL=webpack://SWC/./src/js/swc.js?");

/***/ }),

/***/ "./src/css/swc.css":
/*!*************************!*\
  !*** ./src/css/swc.css ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://SWC/./src/css/swc.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/js/openrouter-client.js");
/******/ 	__webpack_require__("./src/js/context-manager.js");
/******/ 	__webpack_require__("./src/js/swc.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/css/swc.css");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});